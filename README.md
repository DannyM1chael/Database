/**
 *
 * Данный класс использует технологию placeholders - для формирования корректных SQL-запросов, в строке запроса вместо
 * значений пишутся специальные типизированные маркеры - заполнители, а сами данные передаются "позже", в качестве
 * последующих аргументов основного метода, выполняющего SQL-запрос - Krugozor_Database_Mysql::query().
 * Данные, прошедшие через систему placeholders, экранируются специальными функциями экранирования,
 * в зависимости от типа заполнителей. Т.е. вам нет необходимости заключать переменные в функции
 * экранирования типа mysqli_real_escape_string($value) или приводить их к числовому типу через (int)$value.
 *
 *
 *    Типы заполнителей
 *
 * ?i - заполнитель числового типа.
 *      В режиме MODE_TRANSFORM данные принудительно приводятся к типу integer.
 * ?s - заполнитель строкового типа, экранируется всегда.
 *      В режиме MODE_TRANSFORM данные принудительно приводятся к типу string.
 * ?S - заполнитель строкового типа для подстановки в выражение LIKE поиска, экранируется всегда.
 *      В режиме MODE_TRANSFORM данные принудительно приводятся к типу string.
 * ?n - заполнитель NULL типа.
 *      В режиме MODE_TRANSFORM данные принудительно заменяются на NULL.
 * ?At - заполнитель ассоциативного множества из ассоциативного массива ("key_1" => "val_1", "key_2" => "val_2", ...)
 * ?at - заполнитель множества из любого массива ("val_1", "val_2", ...)
 *       где t - один из типов:
 *       - i (int)
 *       - s (string)
 *       правила преобразования и экранирования такие же, как и для одиночных скалярных типов.
 * ?A[?n, ?s, ?i] - заполнитель ассоциативного множества с явным указанием типа и количества аргументов.
 * ?a[?n, ?s, ?i] - заполнитель множества с явным указанием типа и количества аргументов.
 *
 *
 *    Режимы работы.
 *
 * Существует два режима работы метода:
 * Krugozor_Database_Mysql::MODE_STRICT    - строгий режим соответствия типа заполнителя и типа аргумента.
 * Krugozor_Database_Mysql::MODE_TRANSFORM - режим преобразования аргумента к типу заполнителя при несовпадении
 *                                             типа заполнителя и типа аргумента. Установлен по умолчанию.
 *
 *
 *     MODE_STRICT
 *
 * В "строгом" режиме MODE_STRICT аргументы, передаваемые в основной метод
 * Krugozor_Database_Mysql::query(), должны в ТОЧНОСТИ соответствовать типу заполнителя.
 * Разберем примеры:
 *
 * $db->query('SELECT * FROM table WHERE field = ?i', 'вася'); - в данном случае будет выброшено исключение
 *     "Попытка записать как int значение вася типа string в запросе ...", т.к.
 * указан тип заполнителя ?i (int - целое число), а в качестве аргумента передается строка 'вася'.
 *
 * $db->query('SELECT * FROM table WHERE field = "?s"', 123); - будет выброшено исключение
 *     "Попытка записать как string значение 123 типа integer в запросе ...", т.к.
 * указан тип заполнителя ?s (string - строка), а в качестве аргумента передается число 123.
 *
 * $db->query('SELECT * FROM table WHERE field IN (?as)', array(null, 123, true, 'string')); - будет выброшено исключение
 *     "Попытка записать как string значение типа NULL в запросе ...", т.к. заполнитель массива ?a ожидает,
 * что все элементы массива-аргумета будут типа s (string - строка), но на деле все элементы массива представляют собой
 * данные различных типов. Парсер прекратил разбор на первом несоответствии типа - на элементе массива со значением null.

 *
 *     MODE_TRANSFORM
 *
 * Режим MODE_TRANSFORM является "щадящим" режимом и при несоответствии типа заполнителя и аргумента не генерирует
 * исключение, а пытается преобразовать аргумент к нужному типу в соответствии с правилами преобразования типов в PHP.
 *
 * Допускаются следующие преобразования:
 *
 * К строковому типу приводятся данные типа boolean, numeric, NULL:
 *     - значение boolean TRUE преобразуется в строку "1", а значение FALSE преобразуется в "" (пустую строку)
 *     - значение типа numeric преобразуется в строку согласно правилам преобразования, определенным языком
 *     - NULL преобразуется в пустую строку
 * Для массивов, объектов и ресурсов преобразования не допускаются.
 *
 * Пример выражения:
 *     $db->query('SELECT * FROM table WHERE f1 = "?s", f2 = "?s", f3 = "?s"', null, 123, true);
 * Результат преобразования:
 *     SELECT * FROM table WHERE f1 = "", f2 = "123", f3 = "1"
 *
 * К целочисленному типу приводятся данные типа boolean, string, NULL:
 *     - значение boolean FALSE преобразуется в 0 (ноль), а TRUE - в 1 (единицу).
 *     - значение типа string преобразуется согласно правилам преобразования, определенным языком
 *     - NULL преобразуется в 0
 * Для массивов, объектов и ресурсов преобразования не допускаются.
 *
 * Пример выражения:
 *     $db->query('SELECT * FROM table WHERE f1 = ?i, f2 = ?i, f3 = ?i, f4 = ?i', null, '123abc', 'abc', true);
 * Результат преобразования:
 *     SELECT * FROM table WHERE f1 = 0, f2 = 123, f3 = 0, f4 = 1
 *
 * NULL тип замещает аргумент для любого типа данных.
 *
 *
 *    Ограничивающие кавчки
 *
 * Данный класс при формировании SQL-запроса не занимается проставлением ограничивающих кавычек для одиночных
 * заполнителей скалярного типа, таких как ?i и ?s. Это сделано по идеологическим соображениям, автоподстановка кавычек
 * может стать ограничением для возможностей SQL.
 * Например, выражение
 *     $db->query('SELECT "Total: ?s"', '200');
 * вернёт строку
 *     'Total: 200'
 * Если бы кавычки, ограничивающие строковой литерал, ставились бы автоматически,
 * то вышеприведённое условие вернуло бы строку
 *     'Total: "200"'
 * что было бы не ожидаемым поведением для разработчика.
 *
 * Тем не менее, для перечислений ?as, ?ai, ?As и ?Ai ограничивающие кавычки ставятся принудительно, т.к.
 * перечисления всегда используются в запросах, где наличие кавчек обязательно или не играет роли:
 *
 *    $db->query('INSERT INTO test SET ?As', array('name' => 'Маша', 'age' => '23', 'adress' => 'Москва'));
 *    -> INSERT INTO test SET `name` = "Маша", `age` = "23", `adress` = "Москва"
 *
 *    $db->query('SELECT * FROM table WHERE field IN (?as)', array('55', '12', '132'));
 *    -> SELECT * FROM table WHERE field IN ("55", "12", "132")
 */