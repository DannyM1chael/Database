Rus
===

Что такое Database?
---

Database — библиотека классов на PHP 5.3 для простой, удобной, быстрой и безопасной работы с базой данных MySql, использующая расширение PHP mysqli.


Зачем в 2017 году нужен самописный класс для MySql, если в PHP есть абстракция PDO и расширение mysqli?
---

Основные недостатки всех библиотек для работы с базой в PHP это:

* **Многословность**
  * Что бы предотвратить <a href="http://ru.wikipedia.org/wiki/%D0%92%D0%BD%D0%B5%D0%B4%D1%80%D0%B5%D0%BD%D0%B8%D0%B5_SQL-%D0%BA%D0%BE%D0%B4%D0%B0">SQL-инъекции</a>, у разработчиков есть два пути:
    * Использовать <a href="http://php.net/manual/ru/mysqli.quickstart.prepared-statements.php">подготавливаемые запросы</a> (prepared statements).
    * Вручную экранировать параметры идущие в тело SQL-запроса. Строковые параметры прогонять через <a href="http://php.net/manual/ru/mysqli.real-escape-string.php">mysqli_real_escape_string()</a>, а ожидаемые числовые параметры приводить к соответствующим типам — int и float.
  * Оба подхода имеют колоссальные недостатки:
    * Подготавливаемые запросы <a target="_blank" rel="nofollow" href="http://php.net/manual/ru/mysqli.prepare.php#refsect1-mysqli.prepare-examples">ужасно многословны</a>. Пользоваться "из коробки" абстракцией PDO или расширением mysqli, без агрегирования всех методов для получения данных из СУБД просто невозможно — что бы получить значение из таблицы необходимо написать минимум 5 строк кода! И так на каждый запрос!
    * Экранирование вручную параметров, идущих в тело SQL-запроса — даже не обсуждается. Хороший программист — ленивый программист. Всё должно быть максимально автоматизировано.
* **Невозможность получить SQL запрос для отладки**


Решение: Database — класс для работы с MySql
---
1. Избавляет от многословности — вместо 3 и более строк кода для исполнения одного запроса при использовании "родной" библиотеки, вы пишите всего 1!
2. Экранирует все параметры, идущие в тело запроса, согласно указанному типу заполнителей — надежная защита от SQL-инъекций.
3. Не замещает функциональность "родного" mysqli адаптера, а просто дополняет его.


Что такое placeholders (заполнители)?
---

Placeholders (англ. — заполнители) — специальные типизированные маркеры, которые пишутся в строке SQL запроса вместо явных значений (параметров запроса). А сами значения передаются "позже", в качестве последующих аргументов основного метода, выполняющего SQL-запрос:

```php
<?php
// Соединение с СУБД и получение объекта Database_Mysql
// Database_Mysql - "обертка" над "родным" объектом mysqli
$db = Database_Mysql::create("localhost", "root", "password")
      // Выбор базы данных
      ->setDatabaseName("test")
      // Выбор кодировки
      ->setCharset("utf8");

// Получение объекта результата Database_Mysql_Statement
// Database_Mysql_Statement - "обертка" над "родным" объектом mysqli_result
$result = $db->query("SELECT * FROM `users` WHERE `name` = '?s' AND `age` = ?i", "Василий", 30);

// Получаем данные (в виде ассоциативного массива, например)
$data = $result->fetch_assoc();

// Не работает запрос? Не проблема - выведите его на печать:
echo $db->getQueryString();
```

Параметры SQL-запроса, прошедшие через систему placeholders, обрабатываются специальными функциями экранирования, в зависимости от типа заполнителей. Т.е. вам теперь нет необходимости заключать переменные в функции экранирования типа mysqli_real_escape_string() или приводить их к числовому типу, как это было раньше:

```php
<?php
// Раньше перед каждым запросом в СУБД мы делали
// примерно это (а многие и до сих пор `это` не делают):
$id = (int) $_POST['id'];
$value = mysql_real_escape_string($_POST['value'], $link);
$result = mysql_query("SELECT * FROM `t` WHERE `f1` = '$value' AND `f2` = $id", $link);
```

Теперь запросы стало писать легко, быстро, а главное библиотека Database полностью предотвращает любые возможные SQL-инъекции.


Типы заполнителей и типы параметров SQL-запроса
---

Типы заполнителей и их предназначение описываются ниже. Прежде чем знакомиться с типами заполнителей, необходимо понять как работает механизм библиотеки Database.

```php
 $db->query("SELECT ?i", 123); 
```
SQL-запрос после преобразования шаблона:
```sql
SELECT 123
```
В процессе исполнения этой команды библиотека проверяет, является ли аргумент `123` целочисленным значением. Заполнитель ?i представляет собой символ `?` (знак вопроса) и первую букву слова `integer`. Если аргумент действительно представляет собой целочисленный тип данных, то в шаблоне SQL-запроса заполнитель ?i заменяется на значение `123` и SQL передается на исполнение.

Поскольку PHP слаботипизированный язык, то вышеописанное выражение эквивалентно нижеописанному:

```php
 $db->query("SELECT ?i", '123'); 
 ```
 
 SQL-запрос после преобразования шаблона:
 
 ```sql
 SELECT 123
 ```
 
 т.е. числа (целые и с плавающей точкой) представленные как в своем типе, так и в виде string — равнозначны с точки зрения библиотеки.
 
 ### Приведение к типу заполнителя
 
 ```php
  $db->query("SELECT ?i", '123.7'); 
  ```
  SQL-запрос после преобразования шаблона:
  ```sql
  SELECT 123
  ```
  
  В данном примере заполнитель целочисленного типа данных ожидает значение типа integer, а передается double. *По-умолчанию библиотека работает в режиме приведения типов, что дало в итоге приведение типа double к int*.
